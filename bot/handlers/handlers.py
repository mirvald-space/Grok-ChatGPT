import asyncio
import logging
import os
import re
from datetime import datetime, timedelta
from functools import wraps
from typing import Optional, Union

from aiogram import F, Router, types
from aiogram.enums import ChatAction, ParseMode
from aiogram.filters import Command, CommandObject
from aiogram.types import FSInputFile

from bot.database.database import Database, UserManager
from bot.database.models import User
from bot.keyboards.keyboards import get_models_keyboard
from bot.locales.utils import get_text
from bot.services.gpt import GPTService
from bot.services.claude import ClaudeService
from config import (
    DAILY_TOKENS,
    GPT_MODEL,
    CLAUDE_MODEL,
    MODEL_NAMES,
    REFERRAL_TOKENS,
    REQUIRED_CHANNELS,
    YOUR_ADMIN_ID,
)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

MODEL_SERVICES = {
    GPT_MODEL: GPTService(),
    CLAUDE_MODEL: ClaudeService(),
}


router = Router()


def escape_markdown(text):
    """–≠–∫—Ä–∞–Ω–∏—Ä—É–µ—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã MarkdownV2"""
    chars = [
        "_",
        "*",
        "[",
        "]",
        "(",
        ")",
        "~",
        "`",
        ">",
        "#",
        "+",
        "-",
        "=",
        "|",
        "{",
        "}",
        ".",
        "!",
    ]
    for char in chars:
        text = text.replace(char, f"\\{char}")
    return text


def format_to_html(text):
    # –ó–∞–≥–æ–ª–æ–≤–∫–∏
    text = re.sub(r"### \*\*(.*?)\*\*", r"<b><u>\1</u></b>", text)

    # –ñ–∏—Ä–Ω—ã–π —Ç–µ–∫—Å—Ç
    text = re.sub(r"\*\*(.*?)\*\*", r"<b>\1</b>", text)

    # –ö—É—Ä—Å–∏–≤
    text = re.sub(r"\*(.*?)\*", r"<i>\1</i>", text)

    # –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏ - –∑–∞–º–µ–Ω—è–µ–º –Ω–∞ —Å—Ç—Ä–æ–∫—É —Å–∏–º–≤–æ–ª–æ–≤
    text = text.replace("---", "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî")

    return text


async def check_subscription(bot, user_id: int) -> bool:
    """
    Checks if user is subscribed to all required channels.
    Returns True only if subscribed to ALL channels.
    """
    try:
        for channel in REQUIRED_CHANNELS:
            # Remove '@' from the beginning if it exists for API call
            channel_id = channel
            if channel_id.startswith('@'):
                channel_id = channel_id[1:]
                
            member = await bot.get_chat_member('@' + channel_id, user_id)
            if member.status in ["left", "kicked", "banned"]:
                # If not subscribed to any channel, return False immediately
                return False
                
        # If we get here, user is subscribed to all channels
        return True
    except Exception as e:
        logger.error(f"Subscription check failed for user {user_id}: {str(e)}")
        # Return False on any error to be safe
        return False


def require_access(func):
    @wraps(func)
    async def wrapper(message: types.Message, db: Database, *args, **kwargs):
        manager = await db.get_user_manager()
        user = await manager.get_user(
            message.from_user.id,
            message.from_user.username,
            message.from_user.language_code,
        )

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–ø–∏—Å–∫—É –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —Ç–µ–∫—É—â–µ–≥–æ access_granted
        access_granted = await check_subscription(message.bot, user.user_id)

        if not access_granted:
            # –ï—Å–ª–∏ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ
            # Format channels for display, e.g. "@Channel1, @Channel2"
            channels_formatted = ", ".join(REQUIRED_CHANNELS)
                
            await send_localized_message(
                message,
                "access_denied_subscription",
                user,
                channels=channels_formatted,
                reply_markup=get_subscription_keyboard(user.language_code),
            )
            # –ï—Å–ª–∏ access_granted –±—ã–ª True, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –µ–≥–æ –≤ False
            if user.access_granted:
                await manager.update_user(
                    user.user_id,
                    {
                        "access_granted": False,
                        "tariff": "free",
                    },  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–∞—Ä–∏—Ñ –∏ –¥–æ—Å—Ç—É–ø
                )
            return

        # –ï—Å–ª–∏ –ø–æ–¥–ø–∏—Å–∞–Ω, –Ω–æ access_granted –±—ã–ª False, –æ–±–Ω–æ–≤–ª—è–µ–º
        if not user.access_granted:
            await manager.update_user(
                user.user_id,
                {
                    "access_granted": True,
                    "tariff": "paid",
                    "last_daily_reward": datetime.now(),
                },
            )
            user.access_granted = True
            user.tariff = "paid"

        # –í—ã–ø–æ–ª–Ω—è–µ–º –æ—Å–Ω–æ–≤–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
        return await func(message, db, user=user, *args, **kwargs)

    return wrapper


def get_subscription_keyboard(language_code: str) -> types.InlineKeyboardMarkup:
    """Creates a keyboard with buttons to join all required channels"""
    keyboard = []
    
    # Add a button for each channel
    for channel in REQUIRED_CHANNELS:
        # Remove '@' from the beginning if it exists for URL
        channel_id = channel
        if channel_id.startswith('@'):
            channel_id = channel_id[1:]
            
        keyboard.append([
            types.InlineKeyboardButton(
                text=f"{get_text('join_channel_button', language_code)} {channel}",
                url=f"https://t.me/{channel_id}",
            )
        ])
    
    # Add the check subscription button at the end
    keyboard.append([
        types.InlineKeyboardButton(
            text=get_text("check_subscription_button", language_code),
            callback_data="check_subscription",
        )
    ])
    
    return types.InlineKeyboardMarkup(inline_keyboard=keyboard)


async def send_localized_message(
    message: types.Message,
    key: str,
    user: User,
    reply_markup: Optional[types.InlineKeyboardMarkup] = None,
    return_text: bool = False,
    **kwargs,
) -> Union[str, None]:
    kwargs.setdefault("username", user.username or "")
    kwargs.setdefault("invite_link", "")
    text = get_text(key, user.language_code, **kwargs)
    if return_text:
        return text
    await message.answer(text, reply_markup=reply_markup)
    return None


@router.message(Command("send_all"))
async def admin_send_all(message: types.Message, command: CommandObject, db: Database):
    if message.from_user.id != YOUR_ADMIN_ID:
        await message.answer("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã")
        return

    if not command.args:
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /send_all —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è")
        return

    text = command.args
    users = await db.users.find({}).to_list(None)
    success_count = 0
    failed_count = 0

    for user in users:
        try:
            await message.bot.send_message(user["user_id"], text)
            success_count += 1
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {str(e)}")
            failed_count += 1

    await message.answer(
        f"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–π: {success_count}, –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å: {failed_count}"
    )


@router.message(Command("invite"))
@require_access
async def invite_command(message: types.Message, db: Database, user: User):
    invite_link = f"https://t.me/DockMixAIbot?start={user.user_id}"
    text = "\n\n".join(
        [
            f"üîó –í–∞—à–µ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–µ –ø–æ—Å–∏–ª–∞–Ω–Ω—è: {invite_link}",
            f"üë• –í–∏ –∑–∞–ø—Ä–æ—Å–∏–ª–∏: {len(user.invited_users)} –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤",
        ]
    )
    await message.answer(text)


@router.message(Command("start"))
async def start_command(message: types.Message, db: Database):
    manager = await db.get_user_manager()
    user = await manager.get_user(
        message.from_user.id,
        message.from_user.username,
        message.from_user.language_code,
    )

    invite_link = f"https://t.me/DockMixAIbot?start={user.user_id}"
    if len(message.text.split()) > 1:
        await process_referral(message, user, db)

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–ø–∏—Å–∫—É –≤—Å–µ–≥–¥–∞
    access_granted = await check_subscription(message.bot, user.user_id)
    if access_granted and not user.access_granted:
        await manager.update_user(
            user.user_id,
            {
                "access_granted": True,
                "tariff": "paid",
                "last_daily_reward": datetime.now(),
            },
        )
        user.access_granted = True
        user.tariff = "paid"
    elif not access_granted and user.access_granted:
        await manager.update_user(
            user.user_id,
            {"access_granted": False, "tariff": "free"},
        )
        user.access_granted = False
        user.tariff = "free"

    caption_key = "start" if access_granted else "access_denied_subscription"
    
    # Format channels for display, e.g. "@Channel1, @Channel2"
    channels_formatted = ", ".join(REQUIRED_CHANNELS)
        
    caption = await send_localized_message(
        message,
        caption_key,
        user,
        channels=channels_formatted,
        invite_link=invite_link,
        balance=user.balance,
        current_model=user.current_model,
        return_text=True,
    )

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–æ—Ç–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞
    reply_markup = (
        None if access_granted else get_subscription_keyboard(user.language_code)
    )
    if not access_granted:
        photo = FSInputFile("image/welcome.png")
        await message.answer_photo(photo, caption=caption, reply_markup=reply_markup)
    else:
        await message.answer(caption, reply_markup=reply_markup)


@router.callback_query(F.data == "check_subscription")
async def check_subscription_callback(callback: types.CallbackQuery, db: Database):
    manager = await db.get_user_manager()
    user = await manager.get_user(
        callback.from_user.id,
        callback.from_user.username,
        callback.from_user.language_code,
    )
    access_granted = await check_subscription(callback.message.bot, user.user_id)

    if access_granted:
        await manager.update_user(
            user.user_id,
            {
                "access_granted": True,
                "tariff": "paid",
                "last_daily_reward": datetime.now(),
            },
        )
        await callback.message.edit_caption(
            caption=await send_localized_message(
                callback.message, "subscription_confirmed", user, return_text=True
            ),
            reply_markup=None,
        )
        welcome_text = await send_localized_message(
            callback.message,
            "start",
            user,
            balance=user.balance,
            current_model=user.current_model,
            return_text=True,
        )
        await callback.message.answer(welcome_text)
    else:
        # Format channels for alert message
        missing_channels = []
        for channel in REQUIRED_CHANNELS:
            try:
                channel_id = channel
                if channel_id.startswith('@'):
                    channel_id = channel_id[1:]
                    
                member = await callback.message.bot.get_chat_member('@' + channel_id, user.user_id)
                if member.status in ["left", "kicked", "banned"]:
                    missing_channels.append(channel)
            except Exception:
                missing_channels.append(channel)
                
        missing_text = ", ".join(missing_channels) if missing_channels else ", ".join(REQUIRED_CHANNELS)
            
        await callback.answer(
            get_text("still_not_subscribed", user.language_code) + f" {missing_text}", show_alert=True
        )


@router.message(Command("profile"))
@require_access
async def profile_command(message: types.Message, db: Database, user: User):
    await send_localized_message(
        message,
        "profile",
        user,
        user_id=user.user_id,
        balance=user.balance,
        current_model=user.current_model,
    )


@router.message(Command("help"))
@require_access
async def help_command(message: types.Message, db: Database, user: User):
    await send_localized_message(
        message, "help", user, balance=user.balance, current_model=user.current_model
    )


@router.message(Command("reset"))
@require_access
async def reset_command(message: types.Message, db: Database, user: User):
    manager = await db.get_user_manager()
    await manager.update_user(user.user_id, {"messages_history": []})
    await send_localized_message(message, "history_reset", user)


@router.message(Command("models"))
@require_access
async def models_command(message: types.Message, db: Database, user: User):
    await send_localized_message(
        message,
        "select_model",
        user,
        current_model=user.current_model,
        reply_markup=get_models_keyboard(user.language_code),
    )


@router.callback_query(F.data.startswith("model_"))
@require_access
async def change_model_handler(callback: types.CallbackQuery, db: Database, user: User):
    model = callback.data.split("_")[1]
    manager = await db.get_user_manager()
    await manager.update_user(user.user_id, {"current_model": model})
    await send_localized_message(
        callback.message, "model_changed", user, model=MODEL_NAMES[model]
    )








@router.message(Command("audio"))
@require_access
async def audio_command(message: types.Message, db: Database, user: User):
    try:
        text = message.text.split("/audio", 1)[1].strip()
    except IndexError:
        await send_localized_message(message, "audio_prompt_required", user)
        return

    if user.balance < 5:
        await message.answer("–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Ç–æ–∫–µ–Ω—ñ–≤ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó –∞—É–¥—ñ–æ.")
        return

    try:
        await message.bot.send_chat_action(
            chat_id=message.chat.id, action=ChatAction.RECORD_VOICE
        )

        gpt_service = MODEL_SERVICES[GPT_MODEL]
        output_path = f"audio_{message.from_user.id}_{datetime.now().strftime('%Y%m%d%H%M%S')}.mp3"

        await gpt_service.text_to_speech(text, output_path=output_path)

        if os.path.exists(output_path):
            audio = FSInputFile(output_path)
            await message.answer_voice(audio)

            # –î–æ–∂–∏–¥–∞–µ–º—Å—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏, –ø–æ—Ç–æ–º —É–¥–∞–ª—è–µ–º —Ñ–∞–π–ª
            await asyncio.sleep(1)
            os.remove(output_path)

            manager = await db.get_user_manager()
            await manager.update_balance_and_history(
                user.user_id, 5, "tts-1", text, "audio_generated"
            )
        else:
            await message.answer("–ü–æ–º–∏–ª–∫–∞: —Ñ–∞–π–ª –∞—É–¥—ñ–æ –Ω–µ –±—É–≤ —Å—Ç–≤–æ—Ä–µ–Ω–∏–π")
    except Exception as e:
        logger.error(f"Audio generation failed: {str(e)}")
        await message.answer(f"–ü–æ–º–∏–ª–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó –∞—É–¥—ñ–æ: {str(e)}")


async def process_referral(message: types.Message, user: User, db: Database) -> None:
    if len(message.text.split()) <= 1:
        return
    try:
        inviter_id = int(message.text.split()[1])
        if inviter_id == user.user_id:
            await message.answer("‚ùå –í–∏ –Ω–µ –º–æ–∂–µ—Ç–µ –∑–∞–ø—Ä–æ—Å–∏—Ç–∏ —Å–∞–º–æ–≥–æ —Å–µ–±–µ!")
            return

        inviter = await db.users.find_one({"user_id": inviter_id})
        if not inviter or message.from_user.id in inviter.get("invited_users", []):
            return

        manager = await db.get_user_manager()
        await manager.add_invited_user(inviter_id, message.from_user.id)
        await send_inviter_notification(
            inviter_id, len(inviter.get("invited_users", []) + 1), db, message.bot
        )
    except (ValueError, TypeError) as e:
        logger.error(f"–ü–æ–º–∏–ª–∫–∞ –æ–±—Ä–æ–±–∫–∏ —Ä–µ—Ñ–µ—Ä–∞–ª–∞: {str(e)}")


async def send_inviter_notification(
    inviter_id: int, invited_count: int, db: Database, bot
) -> None:
    manager = await db.get_user_manager()
    user = await manager.get_user(
        inviter_id, None, "en"
    )  # Username –Ω–µ –Ω—É–∂–µ–Ω –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
    text = await send_localized_message(
        None,
        "new_invited_user_tokens",
        user,
        invited_count=invited_count,
        referral_tokens=REFERRAL_TOKENS,
        return_text=True,
    )
    await bot.send_message(inviter_id, text)


@router.message()
@require_access
async def handle_message(message: types.Message, db: Database, user: User):
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–∞
    tokens_cost = 0 if user.current_model == "tts-1" else 1
    if user.balance < tokens_cost:
        next_day = (datetime.now() + timedelta(days=1)).strftime("%Y-%m-%d")
        await send_localized_message(message, "no_tokens", user, next_day=next_day)
        return

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ–∂–∏–¥–∞–Ω–∏–∏
    wait_message = await message.answer(
        "‚è≥ –í–∞—à –∑–∞–ø–∏—Ç –æ–±—Ä–æ–±–ª—è—î—Ç—å—Å—è, –±—É–¥—å –ª–∞—Å–∫–∞, –∑–∞—á–µ–∫–∞–π—Ç–µ..."
    )

    try:
        await message.bot.send_chat_action(
            chat_id=message.chat.id, action=ChatAction.TYPING
        )
        service = MODEL_SERVICES.get(user.current_model)
        if not service:
            await message.bot.delete_message(message.chat.id, wait_message.message_id)
            await message.answer(
                "‚ùå –ù–µ–≤—ñ–¥–æ–º–∞ –º–æ–¥–µ–ª—å, —Å–ø—Ä–æ–±—É–π—Ç–µ –≤–∏–±—Ä–∞—Ç–∏ —â–µ —Ä–∞–∑ –º–æ–¥–µ–ª—å /models"
            )
            return

        # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
        if message.photo:
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ç–æ...
            photo = message.photo[-1]
            file = await message.bot.get_file(photo.file_id)
            file_path = f"temp_{message.from_user.id}_{photo.file_id}.jpg"
            await message.bot.download_file(file.file_path, file_path)
            response = await service.read_image(file_path)
            import os

            os.remove(file_path)
        else:
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞...
            history = user.messages_history[-5:]
            context = [
                {
                    "role": "user" if i % 2 == 0 else "assistant",
                    "content": entry["message" if i % 2 == 0 else "response"],
                }
                for i, entry in enumerate(history)
            ]
            response = await service.get_response(message.text, context=context)

        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞
        manager = await db.get_user_manager()
        if not message.photo:
            await manager.update_balance_and_history(
                user.user_id, tokens_cost, user.current_model, message.text, response
            )
        else:
            await manager.update_balance_and_history(
                user.user_id, tokens_cost, user.current_model, "", response
            )

        # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ–∂–∏–¥–∞–Ω–∏–∏
        await message.bot.delete_message(message.chat.id, wait_message.message_id)

        # –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞
        try:
            formatted_response = format_to_html(response)
            await message.answer(formatted_response, parse_mode=ParseMode.HTML)
        except Exception as e:
            await message.answer(response)
            logger.error(f"HTML format error: {str(e)}")
    except Exception as e:
        # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ–∂–∏–¥–∞–Ω–∏–∏ –ø—Ä–∏ –æ—à–∏–±–∫–µ
        await message.bot.delete_message(message.chat.id, wait_message.message_id)
        logger.error(f"Message handling failed: {str(e)}")
        await message.answer(f"–ü–æ–º–∏–ª–∫–∞ –æ–±—Ä–æ–±–∫–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {str(e)}")
